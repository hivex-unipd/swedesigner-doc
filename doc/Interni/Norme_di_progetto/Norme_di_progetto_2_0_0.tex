% Norme di Progetto
% da compilare con il comando pdflatex Norme_di_progetto_x.x.x.tex

\input{../../util/hx-ambiente}

\version{2.0.0}
\creaz{24 dicembre 2016}
\author{\LB}
\supervisor{\GG}
\uso{interno}
\dest{\ALL}
\title{Norme di Progetto}
% \date{9 gennaio 2017}

\begin{document}
\maketitle
\include{diario}
\tableofcontents





%%%%%%%%%%%%%%%%
%%  Introduzione
%%%%%%%%%%%%%%%%

\section{Introduzione}

\subsection{Scopo del documento}
Questo documento, ad uso interno del gruppo, ha lo scopo di definire le norme che i suoi membri sono tenuti a seguire nel corso dello svolgimento del progetto didattico \proj.

Ogni membro ha pertanto l'obbligo di prenderne visione e di rispettare le indicazioni in esso contenute, al fine di rendere maggiormente efficiente il lavoro svolto e garantire l'uniformità dei prodotti realizzati.

Le convenzioni qui riportate hanno lo scopo di:
\begin{itemize}
	\item garantire ordine all'interno dei documenti e delle varie parti della configurazione del prodotto;
	\item mantenere coerenza nelle notazioni e nelle procedure;
	\item minimizzare i conflitti tra i vari ruoli;
	\item garantire che l'\gloss{infrastruttura} di lavoro sia il più possibile semplice e gestibile --- quindi fruibile.
\end{itemize}

\subsection{Struttura del documento}
Il presente documento si divide in tre sezioni principali:
\begin{itemize}
	\item La sezione \ref{sec:primari} regola i due processi primari di:
	\begin{description}
		\item[fornitura] descritto in §5.2 di ISO/IEC 12207-1995;
		\item[sviluppo] descritto in §5.3 di ISO/IEC 12207-1995.
	\end{description}
	\item La sezione \ref{sec:supporto} regola i processi di supporto:
	\begin{description}
		\item[documentazione] descritto in §6.1 di ISO/IEC 12207-1995;
		\item[configurazione] descritto in §6.2 di ISO/IEC 12207-1995;
		\item[verifica] descritto in §6.4 di ISO/IEC 12207-1995;
		\item[validazione] descritto in §6.5 di ISO/IEC 12207-1995.
	\end{description}
	\item La sezione \ref{sec:organizzativi} regola i processi organizzativi:
	\begin{description}
		% \item[strumenti] descritto in §7.2 di ISO/IEC 12207-1995;
		\item[amministrazione] descritto in §7.1 di ISO/IEC 12207-1995.
	\end{description}
\end{itemize}

\subsection{Scopo del prodotto}
\scopo

\subsection{Glossario}
\presgloss

\subsection{Riferimenti} \label{sec:ref}

\subsubsection{Riferimenti normativi}
\begin{itemize}
	\item ISO/IEC 12207-1995: \url{www.math.unipd.it/\~tullio/IS-1/2009/Approfondimenti/ISO_12207-1995.pdf}, visitato in data 08/02/2017;
	\item Capitolato d'appalto dell'azienda \ZU: \url{www.math.unipd.it/~tullio/IS-1/2016/Progetto/C6.pdf}, visitato in data 08/02/2017. % normativo o informativo?
	\item Standard \emph{JavaDoc}: \url{www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html};
	\item \gloss{API} \emph{JSDdoc}: \url{github.com/jsdoc3/jsdoc}.
\end{itemize}

\subsubsection{Riferimenti informativi}
\begin{itemize}
	\item L. Pantieri, \emph{L'arte di scrivere in \gloss{Latex}}: \url{www.lorenzopantieri.net/LaTeX_files/ArteLaTeX.pdf}, visitato in data 08/02/2017;
	\item \emph{SDMetrics User Manual}: \url{www.sdmetrics.com/manual/index.html}, visitato in data 21/02/2017;
%	\item \emph{CodePro Analytix Help Contents}, accessibile da Eclipse;
\end{itemize}




%%%%%%%%%%%%%%%%%%%%
%%  Processi primari
%%%%%%%%%%%%%%%%%%%%

\section{Processi primari} \label{sec:primari}

\subsection{Fornitura}

	\subsubsection{Studio di fattibilità}
	La fase antecedente alla realizzazione del progetto consiste nel fissare delle riunioni in modo che il gruppo possa discutere di esso. È poi compito degli analisti redigere lo studio di fattibilità (\SdF), sulla base di ciò che è emerso dalle riunioni (come ad esempio il dominio applicativo del capitolato).

	Lo studio di fattibilità deve presentare l'analisi svolta dai membri del gruppo riguardo ad ogni capitolato. Per ogni capitolato, gli analisti devono inserire le seguenti sezioni:
	\begin{description}
		\item[descrizione breve] presentazione della proposta di capitolato; 
		\item[dominio applicativo] analisi dell'ambito applicativo della proposta di capitolato; 
		\item[dominio tecnologico] insieme di tecnologie richieste e consigliate per lo sviluppo del progetto;
		\item[aspetti negativi e positivi] analisi delle criticità e delle potenzialità del progetto in esame;
		\item[valutazione finale] sunto dei principali motivi alla base dell'accettazione o del rigetto del capitolato in esame.
	\end{description}

\subsection{Sviluppo}
	\subsubsection{Analisi dei requisiti}
	Al termine dello studio di fattibilità, è compito degli analisti elencare e analizzare i requisiti del prodotto da sviluppare. Essi devono poi documentare l'analisi nel documento di analisi dei requisiti (\AdR); questo documento contiene i requisiti e i casi d'uso individuati nelle riunioni svolte.
	Viene elencata nelle sezioni seguenti la struttura obbligatoria di requisiti e casi d'uso.
		\paragraph{Requisiti} 
		Dopo aver individuato i requisiti tramite le varie riunioni, è compito degli analisti redarne un elenco con la seguente struttura:
			\[R[Tipo][Importanza][ID]\]
		dove:
		\begin{description}
			\item[Tipo] indica il tipo del requisito, che può essere:
				\begin{itemize}
					\item \textbf{F}: funzionale (cioè un servizio che il prodotto è tenuto a fornire);
					\item \textbf{Q}: di qualità;
					\item \textbf{P}: prestazionale;
					\item \textbf{V}: di vincolo.
			\end{itemize}
			\item[Importanza] indica se il requisito è:
			\begin{itemize}
				\item \textbf{O}: obbligatorio;
				\item \textbf{D}: desiderabile;
				\item \textbf{F}: facoltativo. 
			\end{itemize}
			\item[ID] identifica univocamente il requisito.
		\end{description}
		Inoltre, per ogni requisito l'analista deve specificare:
		\begin{itemize}
			\item una breve descrizione di esso;
			\item la fonte da cui deriva:
			\begin{itemize}
				\item Capitolato: il requisito è derivabile direttamente dalla lettura del relativo capitolato d'appalto;
				\item Riunione Esterna: il requisito deriva da una delle riunioni esterne con il proponente;
				\item Interno: il requisito deriva da un'analisi maggiormente approfondita del capitolato C6 da parte degli analisti;
				\item Casi d'uso: il requisito deriva da uno o più casi d'uso identificati.
			\end{itemize}
		\end{itemize}
		\paragraph{Casi d'uso}
		L'analista deve identificare ogni \gloss{caso d'uso} nel modo seguente:
			\[UCx\]
		dove $x$ è un numero che identifica il caso d'uso. Ogni macro-caso d'uso sarà poi analizzato in modo più specifico e identificato dalla notazione $UCp.f$, dove $p$ indica il caso d'uso stesso e $f$ un suo figlio; ogni figlio può a sua volta avere altri figli. Inoltre ogni caso d'uso deve avere le seguenti proprietà:
		\begin{description}
			\item[nome] nome identificativo del caso d'uso;
			\item[attori] attori coinvolti nel caso d'uso;
			\item[descrizione] descrizione del caso d'uso;
			\item[precondizioni] condizioni che devono valere prima del caso d'uso;
			\item[postcondizioni] condizioni che devono valere dopo il caso d'uso;
			\item[\gloss{scenario} principale] descrizione del caso d'uso tramite i casi d'uso figli;
			\item[inclusioni] eventuali inclusioni, se specificate;
			\item[estensioni] eventuali estensioni, se specificate;
			\item[scenari alternativi] descrizione tramite casi d'uso non appartenenti al flusso principale.
		\end{description}

	\subsubsection{Progettazione} \label{sec:design}
	\paragraph{Attività progettuali} Il lavoro dei progettisti consiste nel progettare il software; nello specifico, questo lavoro si articola in due attività:
	\begin{enumerate}
		\item \textbf{Progettazione architetturale} (attività descritta in §5.3.5 di ISO/IEC 12207) --- definire l'architettura del sistema, cioè individuare e descrivere le componenti del sistema, esplicitandone i ruoli e le relazioni tra essi; ogni progettista documenta questa attività nel documento di Specifica Tecnica.
		\item \textbf{Progettazione di dettaglio} (attività descritta in §5.3.6 di ISO/IEC 12207) --- definire, in dettaglio, il \emph{comportamento} delle componenti del sistema; ogni progettista documenta questa attività nel documento di Definizione di Prodotto.
	\end{enumerate}
	Per ognuna di queste due attività, ogni progettista deve definire dei test che permettano la verifica del sistema:
	\begin{enumerate}
		\item durante la progettazione architetturale, i progettisti definiscono i \textbf{test di integrazione}, cioè dei test che verificano il corretto interfacciarsi delle componenti del sistema;
		\item durante la progettazione di dettaglio, la specifica del comportamento di una componente dev'essere accompagnata dalla definizione di un \textbf{test di unità} che verifichi il corretto funzionamento della componente isolata.
	\end{enumerate}

	\paragraph{Diagrammi} Per descrivere l'architettura e il comportamento del sistema i progettisti utilizzano i diagrammi UML descritti qui di seguito, seguendo lo standard UML 2.0:
	\begin{itemize}
		\item Diagramma dei \gloss{package}: raggruppa un numero di elementi UML in una sola unità di livello più alto.
		\item \gloss{Diagramma delle classi}: descrive le interfacce delle componenti del sistema e le relazioni tra esse.
		\item \gloss{Diagramma delle attività}: descrive i passi di una procedura.
		\item Diagramma di sequenza: descrive uno scenario, dove le azioni sono disposte in sequenza e le varie scelte sono già state prese.
	\end{itemize}
	Per disegnare i diagrammi appena esposti, i progettisti devono usare il software \gloss{Astah} ed esportare i diagrammi in formato PNG.

	\paragraph{Stile di progettazione} L'architettura di \proj{} è segue lo stile dell'\textbf{orientazione agli oggetti}; perciò, le componenti software descritte nei diagrammi delle classi sono:
	\begin{itemize}
		\item classi Java;
		\item prototipi di oggetti JavaScript.
	\end{itemize}
	Per comodità, chiameremo “classi” anche i prototipi di oggetti JavaScript, benché tale linguaggio non offra il costrutto \texttt{class} (se non come “zucchero sintattico”). Pertanto, le procedure descritte nei diagrammi delle attività sono:
	\begin{itemize}
		\item in Java, solo ed esclusivamente metodi di classi;
		\item in JavaScript, metodi di classi o funzioni che abbiano un nome esplicito (quindi \textbf{non} anonime).
	\end{itemize}
	Al fine di aumentare la manutenibilità del sistema, i progettisti devono seguire le seguenti regole:
	\begin{itemize}
		\item ogni libreria esterna dev'essere utilizzata come puro servizio: non è possibile modificarne il codice (questo per problemi di tempo);
		\item quando una classe si interfaccia con un'altra, essa non deve conoscere una particolare classe concreta ma soltanto un suo \emph{tipo}, cioè un'interfaccia o una classe astratta;
		\item ogni componente deve avere un compito ben preciso, ricavabile dal proprio nome e dai metodi che costituiscono la propria interfaccia;
		\item i progettisti devono assumere di conoscere soltanto il tipo statico di un oggetto, non il suo tipo dinamico;
		\item i progettisti devono definire solo metodi di istanza (quindi non statici);
		\item se una classe $A$ dipende, per generalizzazione, da una classe $B$, allora dev'essere possibile dire che “ogni $A$ è un $B$”;
		\item i campi dati di ogni classe Java devono essere privati.
	\end{itemize}

	\paragraph{Nomenclatura} Al fine di uniformare il codice che verrà derivato dalla progettazione, i progettisti devono osservare le seguenti norme di nomenclatura:
	\begin{itemize}
		\item ogni componente ha un nome; tale nome:
		\begin{itemize}
			\item è in lingua inglese;
			\item contiene solo caratteri alfanumerici;
			\item ha iniziale alta;
			\item se composto di più termini, ha l'iniziale di ogni termine alta;
			\item è significativo del ruolo della componente nel sistema;
			\item non può essere un termine riservato dei linguaggi Java o JavaScript;
			\item non può essere più lungo di 30 caratteri;
			\item è preferibilmente un sostantivo (eventualmente composto).
		\end{itemize}
		\item ogni metodo di classe (o funzione) ha un nome; tale nome:
		\begin{itemize}
			\item è in lingua inglese;
			\item contiene solo caratteri alfanumerici;
			\item ha iniziale bassa;
			\item se composto di più termini, ha l'iniziale di ogni termine alta, tranne quella del primo termine;
			\item è significativo della funzione del metodo nella classe;
			\item non può essere un termine riservato dei linguaggi Java o JavaScript;
			\item non può essere più lungo di 20 caratteri;
			\item è preferibilmente un verbo (eventualmente composto).
		\end{itemize}
	\end{itemize}

	\subsubsection{Codifica} \label{sec:cod}
	Scopo dell'attività di codifica è implementare in codice quanto descritto nel documento di Definizione di Prodotto. Per mantenere un alto grado di comprensione del codice sorgente, i programmatori devono seguire delle linee guida sulle tecnologie da usare, sulla nomenclatura e sulla documentazione.

	\paragraph{Convenzioni} \label{sec:conv}
	Il team seguirà due diverse convenzioni in base al linguaggio utilizzato. Essendo la parte \gloss{client} scritta in JavaScript, verranno seguite le indicazioni riguardo nomenclatura, regole sull'uso di spazi, indentazioni e commenti descritti su \url{javascript.crockford.com/code.html}. La parte \gloss{server} è scritta in Java e seguirà le indicazioni JavaDoc disponibili su \url{www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html}.
	
	\paragraph{Nomenclatura del codice}
	Al fine di uniformare il codice sorgente, i programmatori devono rispettare le seguenti norme di codifica:
	\begin{itemize}
		\item i nomi di classi e metodi o funzioni devono essere quelli adottati dai progettisti nei documenti di Specifica Tecnica e di Definizione di Prodotto;
		\item i programmatori possono introdurre funzioni ausiliarie non presenti nella progettazione del software;
		\item i programmatori \textbf{non} possono introdurre classi ausiliarie non presenti nella progettazione del software;
		\item i nomi di variabili locali devono seguire le stesse norme di nomenclatura dei metodi, definite in \ref{sec:norme_design}, tranne che devono essere preferibilmente dei sostantivi.
	\end{itemize}
	
	\paragraph{Ricorsione}
	Bisogna sempre evitare la ricorsione. Nel caso fosse molto difficile trovare un metodo iterativo equivalente, è obbligatorio fornire una prova di terminazione dell'algoritmo ricorsivo.

	\paragraph{Documentazione del codice}
	Per facilitare la manutenibilità del codice, i programmatori devono rispettare le seguenti norme sulla documentazione:
	\begin{itemize}
		\item i programmatori devono spiegare, con un commento, ogni componente;
		\item i programmatori devono spiegare, con un commento, ogni metodo e funzione;
		%spiego meglio sotto giusto per allungare un pò e per semplificare tutte le specifiche scritte su javadoc/jsdoc
		%\item la spiegazione di una componente o di un metodo Java deve seguire gli standard di documentazione \emph{JavaDoc};
		%\item la spiegazione di una componente, di un metodo o di una funzione JavaScript deve seguire le linee guida dell'API \emph{JSDdoc} (nei riferimenti informativi);
		\item quando possibile, è bene documentare con un commento in linea parti di codice non immediatamente comprensibili;
		\item ogni commento in linea deve recare uno spazio tra il testo e il marcatore di inizio commento;
		\item è opportuno usare frasi di senso compiuto in modo da essere più chiari possibili;
		\item è preferibile porre il commento sopra una riga di codice anziché alla fine di essa, per una miglior facilità di lettura.
	\end{itemize}
	La documentazione di file e metodi in particolare i programmatori devono seguire le strutture descritte sotto bassate sulle linee guida di \gloss{Javadoc} e Jsdoc.
	\begin{itemize}
		\item all'inizio di ogni file \texttt{.java} si inserisce un commento, riguardante il documento, con la seguente struttura:
		\begin{verbatim}
		/**
		* Descrizione del file
		*
		*
		* @author Autore
		* @version Versione corrente del file
		* @since Versione del prodotto dalla quale è presente il file
		*/
		\end{verbatim}
		\item Per documentazione di inizio file in Javascript rispettare sempre la struttura descritta per i file \texttt{.java} al punto sopra.
		\item all'inizio di ogni metodo Java si inserisce un commento con la struttura descritta in seguito:
		\begin{verbatim}
		/** 
		* Descrizione del metodo
		* @param NomeParametro    Descrizione parametro
		* @return Tiporitorno     Valore di ritorno 
		*/
		\end{verbatim}
		Il numero di \texttt{@param} dipende dal numero di parametri del metodo. Il tag \texttt{@return} si omette nel caso di metodi \texttt{void} e costruttori. Alcuni parametri aggiuntivi posso recare \texttt{@throws TipoEccezione Motivo}, nel caso di eccezioni controllate presenti nel metodo e \texttt{@since} se il metodo è stato inserito in una versione diversa rispetto al file.
		\item all'inizio di ogni funzione JavaScript si inserisce un commento con la seguente struttura:
		\begin{verbatim}
		/** 
		* Descrizione della funzione
		* @param {Tipoparametro} NomeParametro - Descrizione parametro
		*/
		\end{verbatim}
	\end{itemize}
	
	\paragraph{Tecnologie da usare}
	Ogni programmatore deve utilizzare i seguenti editor di testo:
	\begin{itemize}
		\item \emph{Eclipse} per scrivere codice Java;
		\item \emph{JetBrains Webstorm} per scrivere codice JavaScript.
	\end{itemize}
	Il programmatore è tenuto ad accettare la formattazione automatica proposta dall'editor.

	\subsubsection{Strumenti}
		\paragraph{PragmaDB}
		Per tracciare le relazioni tra casi d'uso e requisiti, il gruppo ha scelto di usare \gloss{PragmaDB} (\url{github.com/StefanoMunari/PragmaDB}), software realizzato da studenti degli anni passati.
		
		Esso consente la gestione automatizzata della gerarchia dei casi d'uso, dei requisiti e delle voci del glossario. Risulta quindi un supporto agevole per rendere il lavoro di gruppo in fase di analisi più efficiente, uniforme e coeso. Inoltre permette l'esportazione in Latex delle varie tabelle (requisiti, casi d'uso, glossario\dots) seguendo le linee guida di struttura descritte in questo documento.

		\paragraph{Astah}
		L'editor UML che gli analisti dovranno usare è Astah, creato da \emph{ChangeVision} e disponibile gratuitamente online. Supporta la generazione di tutti i diagrammi che vengono usati dal gruppo (classi, attività, sequenza e package).




%%%%%%%%%%%%%%%%%%%%%%%%
%%  Processi di supporto
%%%%%%%%%%%%%%%%%%%%%%%%

\section{Processi di supporto} \label{sec:supporto}
I processi normati in questa sezione hanno la funzione di supportare gli altri processi, fornendo istruzioni utili alla stesura dei documenti e alla loro verifica.

\subsection{Documentazione} \label{sec:doc}
La documentazione del progetto (ossia tutto ciò che documenta le attività di un progetto) va sviluppata nel \gloss{branch} \texttt{doc} del nostro \gloss{repository}, come motivato nella sezione \ref{sec:config}.

I documenti che svilupperemo sono i seguenti:
\begin{itemize}
	\item Documenti interni al gruppo:
	\begin{itemize}
		\item \textbf{Studio di fattibilità}: vaglia i \emph{pro} e i \emph{contro} di ogni capitolato d'appalto;
		\item \textbf{Norme di progetto}: norma i processi del progetto.
	\end{itemize}
	\item Documenti rivolti non solo al gruppo ma anche ai committenti e/o ai docenti:
	\begin{itemize}
		\item \textbf{Piano di progetto}: dichiara come il gruppo intende gestire le risorse umane e temporali nel corso del progetto;
		\item \textbf{Piano di qualifica}: descrive come il gruppo affronta il problema di garantire la qualità del prodotto da fornire;
		\item \textbf{Analisi dei requisiti}: elenca, descrive e traccia i requisiti e i casi d'uso del prodotto da fornire;
		\item \textbf{Specifica tecnica}: descrive l'architettura logica del sistema da fornire, mostrando ciò che il sistema deve fare senza però fissarne i dettagli implementativi (descrive l'interfaccia di ogni componente del sistema, attraverso più livelli gerarchici di decomposizione);
		\item \textbf{Definizione di prodotto}: rispetto alla specifica tecnica, decompone l'architettura in moduli ad un livello più fine, affinché ogni modulo possegga dimensione, coesione, complessità e accoppiamento tali per cui i moduli possano essere sviluppati in parallelo dai programmatori;
		\item \textbf{Glossario}: riporta specifici termini che il gruppo ha ritenuto opportuno definire. I motivi che portano ad inserire un termine nel glossario sono la sua potenziale ambiguità e/o la sua natura “tecnica”;
		\item \textbf{Manuale utente}: fornisce all'utente una guida completa ed esaustiva di tutte le funzionalità del prodotto;
		\item \textbf{Verbali}: insieme di documenti che riporta i verbali delle riunioni del gruppo (sia quelle interne al gruppo sia quelle in presenza del committente), ognuna identificata univocamente dalla data.
	\end{itemize}
\end{itemize}
Riportiamo qui di seguito le norme che riguardano lo sviluppo della documentazione; quelle enunciate con il condizionale vanno interpretate come consigli.

\subsubsection{Ambiente di lavoro} I documenti vanno mantenuti in una struttura ad albero ben organizzata ma non troppo profonda; il miglior compromesso tra organizzazione e profondità dell'albero è risultato essere il seguente:
\begin{itemize}
	\item \texttt{util} contiene librerie e script utili al gruppo per lo sviluppo della documentazione:
	\begin{itemize}
		\item \texttt{hx-ambiente.tex} --- dichiarazioni di ambiente per i documenti;
		\item \texttt{hx-front.sty} --- frontespizio di ogni documento;
		\item \texttt{hx-macro.sty} --- macro-istruzioni utili ai redattori;
		\item \texttt{hx-vers.sty} --- macro-istruzioni per ottenere il nome dell'ultima versione di ogni documento;
		\item \texttt{gloss.py} --- script che segna la prima occorrenza di ogni termine da glossario in ogni documento.
	\end{itemize}
	\item \texttt{Interni} contiene cartelle con i documenti ad uso interno del gruppo:
	\begin{itemize}
		\item \texttt{Norme_di_progetto};
		\item \texttt{Studio_di_fattibilita};
		\item \texttt{Verbali}.
	\end{itemize}
	\item \texttt{Esterni} contiene cartelle con i documenti ad uso esterno:
	\begin{itemize}
		\item \texttt{Analisi_dei_requisiti};
		\item \texttt{Glossario};
		\item \texttt{Piano_di_progetto};
		\item \texttt{Piano_di_qualifica}.
	\end{itemize}
\end{itemize}

\subsubsection{Nomi, formati e identificazione} Nome ed estensione dei file sono regolati come segue.
\paragraph{Nome} Il nome di un file o di una directory non deve contenere spazi, al fine di facilitare operazioni da riga di comando. Inoltre deve indicare in modo quanto più chiaro e non ambiguo il contenuto del documento stesso. In particolare:
\begin{itemize}
	\item I documenti formali da consegnare avranno un nome composto nel formato
	\begin{center}
		Nome\_Del\_Documento\_x\_y\_z
	\end{center}
	dove $x.y.z$ è il numero di versionamento: ogni versione di un documento è identificata univocamente dal nome del file e da una seconda stringa con il numero di versionamento che deve seguire le regole esposte nella sezione \ref{sec:idvers}.
	\item I file Latex che definiscono delle macro-istruzioni o danno istruzioni di stile devono iniziare con la sigla “hx-” (per rimarcare che sono librerie create dal gruppo).
\end{itemize}
\paragraph{Formato} Ogni documento dev'essere in formato Latex con estensione \texttt{.tex} (esportabile in formato \gloss{PDF} su foglio A4); la prima versione di un documento può essere in altri formati ma va presto sostituita da una versione in Latex. I file Latex che definiscano delle macro o diano istruzioni di stile iniziano con la sigla “hx-” (per rimarcare che sono librerie create dal gruppo), hanno estensione \texttt{.sty} (tranne “hx-ambiente”, per permetterne l'inclusione prima di dichiarare la classe del documento) e vanno inclusi con il comando \texttt{\textbackslash usepackage\{\}}.

\subsubsection{Struttura di un documento}
\paragraph{Frontespizio} Ogni documento che sia più lungo di una pagina deve iniziare con un frontespizio recante:
\begin{itemize}
	\item logo del gruppo;
	\item nome del gruppo;
	\item nome del progetto;
	\item nome del documento;
	\item versione del documento;
	\item data di creazione del documento;
	\item data di ultima modifica del documento;
	\item nome e cognome dei membri del gruppo incaricati della redazione del documento;
	\item nome e cognome dei membri del gruppo incaricati della verifica del documento;
	\item destinazione d'uso del documento;
	\item destinatari del documento;
	\item mail del gruppo;
	\item riferimento al repository pubblico di \gloss{GitHub}.
\end{itemize} 
Per rispettare tale struttura il redattore del documento deve inserire \\\texttt{\textbackslash input\{../../util/hx-ambiente\}} all'inizio del documento; a seguire deve inserire i comandi \texttt{\textbackslash version\{\}}, \texttt{\textbackslash creaz\{\}}, \texttt{\textbackslash author\{\}}, \texttt{\textbackslash supervisor\{\}}, \texttt{\textbackslash uso\{\}}, \texttt{\textbackslash dest\{\}} e \texttt{\textbackslash title\{\}}; all'interno delle parentesi graffe di ognuno, vanno messe le informazioni corrette per quel documento. Per generare il frontespizio, va usato il comando \texttt{\textbackslash maketitle}, da inserirsi subito dopo l'istruzione \texttt{\textbackslash begin\{document\}}.
\paragraph{Diario delle modifiche} Ogni documento deve includere un diario delle modifiche che elenca, dal più recente al più datato, i cambiamenti apportati a ogni versione rispetto alla precedente, assieme all'autore e alla data di tali cambiamenti. Per questo, il redattore deve inserire dopo l'istruzione \texttt{\textbackslash maketitle} il comando \texttt{\textbackslash include\{diario\}} allo scopo di includere un file intitolato \texttt{diario.tex} posto nella stessa cartella del documento. \texttt{diario.tex} deve presentare solo ed esclusivamente una tabella costruita con l'ambiente \texttt{diario}, funzionante allo stesso modo dell'ambiente \texttt{tabular}. Ogni riga della tabella del diario delle modifiche dev'essere così strutturata:
\begin{itemize}
 \item Versione: versione del documento dopo la modifica;
 \item Autore e Ruolo: autore della modifica e ruolo che esso ricopre;
 \item Data: data della modifica apportata;
 \item Descrizione: descrizione della modifica apportata.
\end{itemize}
\paragraph{Indice dei contenuti} Documenti con più di tre o quattro sezioni devono riportare, all'inizio, un indice dei contenuti. Per questo, dopo l'inclusione del diario delle modifiche va posto il comando \texttt{\textbackslash tableofcontents}.
\paragraph{Sezionamento} Dev'esserci un'unica struttura gerarchica di sezioni comune a tutta la documentazione: il sezionamento principale si attua con \texttt{\textbackslash section\{\}}; poi si scende nello specifico con \texttt{\textbackslash subsection\{\}}, \texttt{\textbackslash subsubsection\{\}} e infine \texttt{\textbackslash paragraph\{\}}. Questi quattro livelli di sezionamento generano parti di testo che vengono tracciate dall'indice generale e sono quindi atti a contenere parti di testo leggibili “ad accesso casuale” (cioè anche senza dover rileggere parti di testo precedenti); per quelle parti di testo che, pur avendo una propria strutturazione, vanno lette in modo “sequenziale”, il redattore deve invece usare gli elenchi; questi \emph{non} vengono riportati nell'indice generale e possono essere di tre tipi:
\begin{description}
	\item[elenchi puntati] elencano gli elementi di un insieme (ambiente \texttt{itemize});
	\item[elenchi numerati] elencano gli elementi di una sequenza (ambiente \texttt{enumerate});
	\item[elenchi descrittivi] elencano gli elementi di un dizionario di termini (ambiente \texttt{description}).
\end{description}
Il redattore di un documento è tenuto a preferire gli elenchi appena esposti a quelli “in linea” (cioè separati solo da un punto e virgola), per aumentare la chiarezza del testo.
\paragraph{Intestazione} Ogni pagina dev'essere numerata, tranne il frontespizio. Inoltre, ogni pagina deve recare nome del progetto, logo del gruppo e e-mail di contatto del gruppo.

\subsubsection{Ciclo di vita di un documento} Per ogni documento creato, i redattori stendono una bozza (in Latex) che dev'essere poi controllata dai verificatori; se questi rilevano errori o possibili miglioramenti da apportare, segnalano il fatto al responsabile di progetto --- che provvede a rendicontare le ore di lavoro aggiuntive --- e modificano il documento dopo aver avvisato i redattori di tale documento.

\subsubsection{Termini del glossario} All'interno di un documento, la prima occorrenza di un termine che si trovi nel glossario dev'essere evidenziata e segnata con il pedice “\ped{$g$}” tramite la macro \texttt{\textbackslash gloss\{termine\}}, per indicare al lettore di ricercarne il significato nel glossario. La segnatura dei termini dev'essere fatta in modo automatizzato, tramite lo script \texttt{gloss.py} nella cartella \texttt{util}.

\subsubsection{Grammatica e tipografia} Tutti i documenti vanno redatti in italiano, con uno stile chiaro e poco articolato. I documenti in italiano osservano le usuali regole grammaticali, tra cui evidenziamo:
\begin{itemize}
	\item La punteggiatura è seguita ma non preceduta da uno spazio.
	\item Le parole straniere di uso comune (computer, radar, web\dots) non vanno evidenziate, per non appesantire il testo; vanno invece evidenziate quelle straniere di uso \emph{non} comune, come \emph{management} o \emph{way of working}. Quando un termine straniero ha una traduzione italiana che non sia troppo strana o artificiosa, va preferita la traduzione italiana.
	\item Gli elementi di un elenco sono separati da un punto e virgola (quindi iniziano con lettera minuscola), tranne l'ultimo che si conclude con un punto. Nel caso che anche un solo elemento dell'elenco si componga di più frasi separate da segno di punteggiatura forte, tutti gli elementi dell'elenco iniziano per maiuscola e finiscono con un punto. In entrambi i casi, ogni elenco è introdotto dai due punti.
	\item Le abbreviazioni vanno scritte interamente in maiuscolo e definite nel glossario.
\end{itemize}
L'evidenziazione di un termine va fatta con \texttt{\textbackslash emph\{\}}. Ogni altro dubbio su grammatica o tipografia va chiarito consultando l'appendice A del testo open-source \url{www.lorenzopantieri.net/LaTeX_files/ArteLaTeX.pdf} (vedi sezione \ref{sec:ref}).

\subsubsection{Macro-istruzioni Latex}
Per uniformare il testo, i redattori sono tenuti a usare le seguenti macro-istruzioni Latex, definite nelle librerie della directory \texttt{util}:
\begin{itemize}
	\item \texttt{\textbackslash proj}, il nome del progetto;
	\item \texttt{\textbackslash hx}, il nome del gruppo;
	\item \texttt{\textbackslash repo}, l'indirizzo web del repository;
	\item \texttt{\textbackslash email}, l'indirizzo e-mail del gruppo;
	\item \texttt{\textbackslash scopo}, il testo contenenete lo scopo del prodotto (da riportare nell'introduzione di ogni documento);
	\item \texttt{\textbackslash presgloss}, il testo contenenete le istruzioni per l'uso del glossario (da riportare nell'introduzione di ogni documento);
	\item \texttt{\textbackslash PB}, \PB;
	\item \texttt{\textbackslash LB}, \LB;
	\item \texttt{\textbackslash GG}, \GG;
	\item \texttt{\textbackslash MM}, \MM;
	\item \texttt{\textbackslash LS}, \LS;
	\item \texttt{\textbackslash AZ}, \AZ;
	\item \texttt{\textbackslash ALL}, \ALL;
	\item \texttt{\textbackslash TV}, \TV;
	\item \texttt{\textbackslash RC}, \RC;
	\item \texttt{\textbackslash GP}, \GP;
	\item \texttt{\textbackslash ZU}, \ZU.
\end{itemize}

\subsubsection{Accessibilità per la stampa} Un documento dev'essere fruibile anche se stampato. Per questo, i collegamenti web vanno scritti esplicitamente con \texttt{\textbackslash url\{indirizzo.del.collegamento\}} anziché nascosti da una parola del testo (come in \texttt{\textbackslash href\{indirizzo.del.collegamento\}\{clicca qui\}}). Inoltre, va minimizzato l'uso di colori, al fine di evitare ambiguità se un documento viene stampato in bassa qualità.



\subsection{Configurazione} \label{sec:config}
Definiamo la configurazione di un prodotto come l'insieme delle parti di cui si compone e il modo in cui esse interagiscono fra di loro. Per gestire la configurazione del software va utilizzato il sistema \gloss{Git}, appoggiandosi alla piattaforma GitHub. Abbiamo scelto GitHub non solo per la qualità del servizio fornito ma anche per la natura open-source del progetto \proj, che ci abilita ad usare questa piattaforma gratuitamente. Il repository creato all'indirizzo \repo{} si divide nelle seguenti directory:
\begin{description}
	\item[\texttt{doc}] per la documentazione;
	\item[\texttt{src}] per il codice sorgente.
\end{description}

\subsubsection{Identificazione e versionamento} \label{sec:idvers}
La configurazione del nostro software si compone dei seguenti elementi:
\begin{itemize}
	\item directory contenenti codice sorgente e materiale correlato;
	\item singoli file contenenti un documento.
\end{itemize}
Ogni elemento della configurazione (quindi la directory per il codice e il singolo file per i documenti) deve avere una versione, che lo identifica nel tempo. La versione si compone di tre numeri separati da un punto: il primo viene incrementato ad ogni \textbf{approvazione} dell'elemento da parte del responsabile di progetto; il secondo ad ogni sua \textbf{revisione} da parte di un verificatore; il terzo ad ogni \textbf{aggiunta o modifica} sostanziale ad esso. L'incremento di un numero azzera i numeri alla sua destra.

\subsubsection{Controllo della configurazione} I cambiamenti \emph{sostanziali} nella configurazione del software vanno controllati e registrati; essi possono nascere dal piano di progetto o dall'iniziativa di un membro.
\paragraph{Cambiamenti pianificati} I cambiamenti pianificati nascono dal piano di progetto. In questo caso il cambiamento è già controllato quindi basta registrarlo aggiornando la versione dell'elemento che è cambiato nella configurazione.
\paragraph{Cambiamenti non pianificati} I cambiamenti \emph{non} pianificati nascono dall'iniziativa di un membro. Un cambiamento di questo tipo va proposto agli altri membri del gruppo sull'apposito canale \gloss{Slack}; nel caso la maggioranza sia d'accordo e riesca a fornire una motivazione del cambiamento, il responsabile di progetto incarica un amministratore di implementarlo e motivarlo nella documentazione.
\paragraph{Branching} Nel caso si debba cambiare un elemento della configurazione da cui dipendono altri elementi --- modificando quindi gli elementi dipendenti --- il membro del gruppo che è stato incaricato di tale cambiamento deve creare un branch nel repository. Un branch (ramo) sottosta alle seguenti regole:
\begin{itemize}
	\item Il ramo \texttt{master} contiene solo elementi della configurazione approvati dal responsabile di progetto.
	\item Il ramo \texttt{doc}, figlio di \texttt{master}, contiene documentazione non ancora approvata dal responsabile di progetto.
	\item Il ramo \texttt{develop}, figlio di \texttt{master}, contiene codice sorgente non ancora approvato dal responsabile di progetto.
	\item Il numero di rami va contenuto, affinché Git rimanga uno strumento e non diventi un peso per i membri del gruppo: la creazione di un nuovo ramo può avvenire solo previa autorizzazione del responsabile di progetto, che dovrà valutarne l'utilità.
	\item Il \emph{merge} di un ramo va sottoposto ad un verificatore (tramite una \emph{merge request}) e va approvato dal responsabile di progetto.
\end{itemize}

\subsubsection{Stato della configurazione}
Nel ramo \texttt{master} del repository va pubblicato lo stato attuale della configurazione, cioè va riportato il numero di versione dell'ultima approvazione formale dell'\emph{intero} software, a partire dalla versione zero (non ancora approvata).



\subsection{Verifica}
Il processo di verifica consiste nel controllare i prodotti in modo che rispettino i requisiti. % processi, oltre ai prodotti?
La verifica è un processo analitico che va implementato in due passi successivi:
\begin{enumerate}
	\item attività di analisi statica;
	\item attività di analisi dinamica.
\end{enumerate}

	\subsubsection{Analisi statica}
	L'analisi statica è una tecnica che permette di individuare anomalie all'interno di documenti e codice sorgente durante tutto il loro ciclo di vita. È applicabile tramite due tecniche diverse:
	\begin{description}
		\item[Walkthrough] Questa tecnica prevede che un verificatore scorra il documento alla ricerca di anomalie ed errori, senza però sapere di preciso quali cercare. È molto utile nelle fasi iniziali di sviluppo, quando il gruppo è ancora inesperto e non si conosce la natura degli errori. Dev'essere adottata dai verificatori, i quali scrivono nella lista di controllo (definita più avanti in questa sezione) gli errori più frequenti; ognuno di questi errori dev'essere cercato tramite inspection.
		\item[Inspection] Con questa tecnica, il verificatore deve utilizzare la lista di controllo in modo tale da eseguire una ricerca molto più mirata e dettagliata degli errori. Quando possibile, il verificatore deve avvalersi degli strumenti automatici che il gruppo sceglierà dopo aver deciso il linguaggio di programmazione da utilizzare.
	\end{description}
	La lista di controllo per i verificatori viene mantenuta e aggiornata nel presente documento; ogni suo elemento è identificato da un'espressione che lo descrive.
	\paragraph{Lista di controllo per la documentazione} Gli elementi da verificare per la documentazione sono i seguenti:
	\begin{description} %%% DA RIEMPIRE MAN MANO
		\item[norme sulla documentazione] i documenti devono rispettare tutte le norme descritte nella sezione \ref{sec:doc};
		\item[completezza] ogni documento deve riportare tutto il necessario per adempiere al suo scopo, riportato nella sua introduzione;
		\item[sintassi Latex] il documento deve usare le macro-istruzioni definite nei file della directory \texttt{util} del ramo \texttt{doc} del nostro repository;
		\item[coerenza] le asserzioni di un documento non devono contraddirsi l'un l'altra né contraddire quelle del resto della documentazione.
	\end{description}
	\paragraph{Lista di controllo per il codice} Gli elementi da verificare per il codice sorgente sono i seguenti:
	\begin{description} %%% DA RIEMPIRE MAN MANO
		\item[norme sulla codifica] il codice deve rispettare tutte le norme descritte nella sezione \ref{sec:cod};
		\item[tracciabilità] l'esistenza di ogni unità del codice dev'essere tracciabile in riferimento alla progettazione.
	\end{description}
 
	\subsubsection{Analisi dinamica}
	L'analisi dinamica viene effettuata tramite dei test sul software prodotto. Questi test devono verificare la correttezza del software e devono essere ripetibili.
	\paragraph{Test di unità}
		I test di unità hanno lo scopo di verificare che ogni singola unità (parte di un componente software) funzioni correttamente; definiamo un'unità come la più piccola quantità di software che conviene verificare da sola. Vengono identificati dalla seguente sintassi:
			\[TU[Codice Test]\]
	\paragraph{Test di integrazione}
		I test di integrazione consentono di controllare che più unità funzionino assieme in modo corretto. Vengono identificati dalla seguente sintassi:
			\[TI[Codice Test]\]
	\paragraph{Test di sistema}
		I test di sistema vengono eseguiti su un prodotto ritenuto completo per verificarne i requisiti. Vengono identificati dalla seguente sintassi:
			\[TS[Codice Requisito]\]
	\paragraph{Test di validazione}
		I test di validazione vengono eseguiti con il proponente per collaudare il prodotto. Vengono identificati dalla seguente sintassi:
			\[TV[Codice Requisito]\]

\subsubsection{Metriche}
	Nel contesto dell'attività di verifica dei processi istanziati nel corso dell'attività di progetto e dell'analisi statica dei relativi prodotti (codice, documenti, design architetturale) vengono in seguito definite delle metriche utili alla misurazione quantitativa degli obiettivi i qualità come definiti nella sezione relativa del documento \PdQ .
	Per ognuna delle metriche viene definito il nome, lo strumento utilizzato per effettuare la relativa misurazione e il range o il valore di accettazione per essa stabilito.
	
			
			\subparagraph{Copertura dei requisiti obbligatori}
			La misura viene effettuata prendendo in considerazione le informazioni aggiornate nel database di PragmaDB a seguito dell'esecuzione con successo dei relativi test di sistema.
			\\Il valore di accettazione stabilito per la metrica è 100.
			
			\subparagraph{Copertura requisiti desiderabili}
			La misura viene effettuata prendendo in considerazione le informazioni aggiornate nel database di PragmaDB a seguito dell'esecuzione con successo dei relativi test di sistema.
			\\Il range di accettazione stabilito per la metrica è 50 - 100.
		
			\subparagraph{Percentuale di test superati}
			La misura viene effettuata prendendo in considerazione le informazioni aggiornate nel database di PragmaDB a seguito dell'esecuzione con successo dei relativi test di sistema.
			\\Il range di accettazione stabilito per la metrica è 90 - 100.
			
			\subparagraph{Profondità di annidamento dei blocchi}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix.
			\\Il range di accettazione stabilito per la metrica è 0 - 8.
			
			\subparagraph{Numero di linee di codice per metodo}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix.
			\\Il range di accettazione stabilito per la metrica è 0 - 40.
			
			\subparagraph{Numero di parametri per metodo}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix.
			\\Il range di accettazione stabilito per la metrica è 0 - 8.
			
			\subparagraph{Numero di campi dati per classe}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix per la codifica e SDMetrics per la progettazione.
			\\Il range di accettazione stabilito per la metrica è 0 - 20.
			
			\subparagraph{Numero di metodi per classe}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix per la codifica e SDMetrics per la progettazione.
			\\Il range di accettazione stabilito per la metrica è 0 - 20.
			
			\subparagraph{Grado di accoppiamento afferente per package}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix per la codifica e SDMetrics per la progettazione.
			\\Il range di accettazione stabilito per la metrica è 0 - 39.
			
			\subparagraph{Grado di accoppiamento efferente per package}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix per la codifica e SDMetrics per la progettazione.
			\\Il range di accettazione stabilito per la metrica è 0 - 16.
			
			\subparagraph{Complessità ciclomatica per metodo}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix.
			\\Il range di accettazione stabilito per la metrica è 0 - 10.
			
			\subparagraph{Numero di tipi per package}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix per la codifica e SDMetrics per la progettazione.
			\\Il range di accettazione stabilito per la metrica è 0 - 30.
			
			\subparagraph{Distanza dalla sequenza principale normalizzata}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix per la codifica e SDMetrics per la progettazione.
			\\Il range di accettazione stabilito per la metrica è 0.0 - 0.7.
			
			\subparagraph{Instabilità}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix per la codifica e SDMetrics per la progettazione.
			\\I range di accettazione stabiliti per la metrica sono 0.0 - 0.4 e 0.6 - 1.0.
			
			\subparagraph{Percentuale linee di commento su linee di codice}
			La misura viene effettuata utilizzando lo strumento CodePro Analytix.
			\\Il range di accettazione stabilito per la metrica è 20 - 40.
			
			\subparagraph{Validazione \gloss{W3C}}
			La misura viene effettuata utilizzando il validatore W3C disponibile all'indirizzo \url{validator.w3.org/}.
			\\Il range di accettazione stabilito per la metrica è 0 - 20.
			
			\subparagraph{Schedule Variance}
			La misura viene effettuata utilizzando lo strumento \gloss{Asana}.
			\\Il range di accettazione stabilito per la metrica è -25 - 0.
			
			\subparagraph{Budget Variance}
			La misura viene effettuata utilizzando lo strumento Asana.
			\\Il range di accettazione stabilito per la metrica è -25 - 0.
			
			\subparagraph{Numero di violazioni di alta importanza delle norme di codifica}
			La misura viene effettuata utilizzando CodePro Analytix.
			\\Il valore di accettazione stabilito per la metrica è 0.
			
			\subparagraph{Numero di violazioni di media importanza delle norme di codifica}
			La misura viene effettuata utilizzando CodePro Analytix.
			\\Il range di accettazione stabilito per la metrica è 0 - 5.
			
			\subparagraph{Numero di violazioni di bassa importanza delle norme di codifica}
			La misura viene effettuata utilizzando CodePro Analytix.
			\\Il range di accettazione stabilito per la metrica è 0 - 10.
			
			\subparagraph{Indice di Gulpease}
			La misura viene effettuata utilizzando un apposito script in Perl.
			\\Il range di accettazione stabilito per la metrica è 40 - 100.
			
			\subparagraph{Numero di violazioni della completezza architetturale di alta importanza}
			La misura viene effettuata utilizzando SDMetrics.
			\\Il valore di accettazione stabilito per la metrica è 0.
			
			\subparagraph{Numero di violazioni della completezza architetturale di media importanza}
			La misura viene effettuata utilizzando SDMetrics.
			\\Il range di accettazione stabilito per la metrica è 0 - 5.
			
			\subparagraph{Numero di violazioni della completezza architetturale di bassa importanza}
			La misura viene effettuata utilizzando SDMetrics.
			\\Il range di accettazione stabilito per la metrica è 0 - 10.
			
			\subparagraph{Numero di violazioni dello stile architetturale di alta importanza}
			La misura viene effettuata utilizzando SDMetrics.
			\\Il valore di accettazione stabilito per la metrica è 0.
			
			\subparagraph{Numero di violazioni dello stile architetturale di media importanza}
			La misura viene effettuata utilizzando SDMetrics.
			\\Il range di accettazione stabilito per la metrica è 0 - 5.
			
			\subparagraph{Numero di violazioni dello stile architetturale di bassa importanza}
			La misura viene effettuata utilizzando SDMetrics.
			\\Il range di accettazione stabilito per la metrica è 0 - 10.
			
			\subparagraph{Numero di violazioni della correttezza architetturale di alta importanza}
			La misura viene effettuata utilizzando SDMetrics.
			\\Il valore di accettazione stabilito per la metrica è 0.
			
			\subparagraph{Numero di violazioni della correttezza architetturale di media importanza}
			La misura viene effettuata utilizzando SDMetrics.
			\\Il range di accettazione stabilito per la metrica è 0 - 5.
			
			\subparagraph{Numero di violazioni della correttezza architetturale di bassa importanza}
			La misura viene effettuata utilizzando SDMetrics.
			\\Il range di accettazione stabilito per la metrica è 0 - 10.
			
			\subparagraph{Statement Coverage}
			La misura viene effettuata utilizzando lo strumento \gloss{Travis} CI.
			\\Il range di accettazione stabilito per la metrica è 80 - 100.
			
			\subparagraph{Branch Coverage}
			La misura viene effettuata utilizzando lo strumento Travis CI.
			\\Il range di accettazione stabilito per la metrica è 80 - 100.
			
			\subparagraph{Percentuale di test di unità eseguiti}
			La misura viene effettuata utilizzando lo strumento Travis CI.
			\\Il range di accettazione stabilito per la metrica è 90 - 100.
			
			\subparagraph{Percentuale di test di integrazione eseguiti}
			La misura viene effettuata utilizzando lo strumento Travis CI.
			\\Il range di accettazione stabilito per la metrica è 90 - 100.
			
			\subparagraph{Percentuale di test di sistema eseguiti}
			La misura viene effettuata utilizzando lo strumento Travis CI.
			\\Il range di accettazione stabilito per la metrica è 90 - 100.
			
			\subparagraph{Percentuale di test di validazione eseguiti}
			La misura viene effettuata utilizzando utilizzando lo strumento Travis CI.
			\\Il range di accettazione stabilito per la metrica è 90 - 100.
			
			\subparagraph{Numero di figli diretti}
			La misura viene effettuata utilizzando SDMetrics per la progettazione e CodePro Analytix per la codifica.
			\\Il range di accettazione stabilito per la metrica è 0 - 4.
			
			\subparagraph{Profondità nella gerarchia}
			La misura viene effettuata utilizzando SDMetrics per la progettazione e CodePro Analytix per la codifica.
			\\Il range di accettazione stabilito per la metrica è 0 - 4.

	\subsubsection{Strumenti}
	In questa sezione vengono dettagliate le caratteristiche e funzionalità degli strumenti automatici scelti per la misurazione delle metriche definite nel paragrafo precedente.
		\subparagraph{SDMetrics}
		SDMetrics fornisce:
		\begin{itemize}
			\item un ampio insieme di misurazioni per la progettazione;
			\item un complesso di regole per il controllo della progettazione;
			\item una serie di feedback proattivi sulla qualità degli schemi di progettazione realizzati;
			\item un insieme estendibile di misurazioni per la progettazione e di regole di progettazione;
			\item interoperabilità con gli strumenti UML;
			\item la possibilità di esportare i risultati delle misurazioni;
			\item un interfaccia grafica interattiva;
			\item velocita nel processare le informazioni e fornire i risultati;
		\end{itemize}

		\subparagraph{CodePRO Analytix}
		CodePRO Analytix fornisce:
		\begin{itemize}
			\item analisi statica del codice con più di 1200 regole di controllo del codice;
			\item rilevamento dei difetti e suggerimento di azioni di riparazione;
			\item possibilità di definire insiemi di regole di controllo personalizzate;
			\item analisi della copertura del codice;
			\item intergazione con Eclipse.
		\end{itemize}

\subsection{Validazione}
Ogni verifica di una parte della configurazione dev'essere vagliata dal responsabile di progetto; per questo, il responsabile deve controllare i risultati dei test. Egli può approvarli oppure chiedere ai verificatori di ripeterli. L'approvazione determina:
\begin{itemize}
	\item l'incremento del numero di versione, secondo le norme in sezione \ref{sec:idvers};
	\item la pubblicazione dei componenti validati e dei test eseguiti sul ramo \texttt{master} del repository.
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Processi organizzativi
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Processi organizzativi} \label{sec:organizzativi}
I processi normati in questa sezione servono all'organizzazione che li istanzia a progetto, cioè servono al gruppo.

\subsection{Gestione di progetto}

\subsubsection{Ruoli} \label{sec:ruoli}
Verranno assegnati dei ruoli corrispondenti a quelli professionali per lo sviluppo del progetto. Ogni membro del team è tenuto a ricoprire almeno una volta tutti i ruoli sotto indicati. Sarà inoltre garantito che non si presentino conflitti di interesse se una persona è sia redattore che verificatore di uno stesso documento. È possibile ricoprire più ruoli contemporaneamente.
\paragraph{Responsabile di progetto}
Il responsabile di progetto detiene la responsabilità di tutto il team ed il potere decisionale. Si occupa inoltre delle comunicazione esterne del team.
In particolare ha responsabilità riguardo a:
\begin{itemize}
	\item Coordinamento, pianificazione e controllo delle attività;
	\item Gestione delle risorse;
	\item Analisi e gestione dei rischi;
	\item Approvazione dei documenti;
	\item Comunicazioni esterne;
	\item Assegnazione compiti ai vari individui;
	\item Convocazioni riunioni interne.
\end{itemize}
I suoi compiti saranno quindi:
\begin{itemize}
	\item Redigere organigramma e il piano di progetto;
	\item Collaborare nella stesura del piano di qualifica;
	\item Assicurarsi che le attività svolte seguano le indicazioni delle norme di progetto;
	\item Garantire che vengano rispettati i ruoli;
	\item Evitare conflitti di interesse tra redattori e verificatori;
	\item Assegnare e gestire task agli altri membri del gruppo;
	\item Approvare in modo definito i documenti.
\end{itemize}
\paragraph{Amministratore}
L'amministratore ha la responsabilità sull'ambiente di lavoro.
I suoi compiti sono quindi:
\begin{itemize}
	\item Gestione ambiente di lavoro attrezzando il team di strumenti necessari;
	\item Aggiungere all'ambiente di lavoro strumenti di automazione del lavoro;
	\item Gestione e versionamento della documentazione;
	\item Controllo versioni e configurazioni del prodotto;
	\item Risoluzione problemi riguardanti la gestione delle risorse e dei processi.
\end{itemize}
L'amministratore è incaricato di redigere le norme di progetto, la parte del piano di qualifica riguardante metodi e strumenti di verifica e collabora alla stesura del piano di progetto.
\paragraph{Analista}
L'analista è responsabile di tutto quello che riguarda l'analisi del problema.
In particolare dovrà:
\begin{itemize}
	\item Studiare a fondo natura e problematiche del prodotto che si andrà a realizzare;
	\item Classificare requisiti;
	\item Redigere diagrammi dei casi d'uso
	\item Produrre una specifica di progetto precisa in ogni sui punto e comprensibile dal proponente, dal committente e dai progettisti.
	\item Redigere lo studio di fattibilità e l'analisi dei requisiti.
\end{itemize}
L'analista redige lo studio di fattibilità e l'analisi dei requisiti.
\paragraph{Progettista}
Il progettista è responsabile delle attività di progettazione. Si occupa più in dettaglio di:
\begin{itemize}
	\item effettuare scelte progettuali volte ad applicare al prodotto soluzioni note ed ottimizzate;
	\item effettuare scelte procedurali volte ad avere un prodotto facilmente espandibile e mantenibile;
	\item produrre una soluzione comprensibile e soddisfacente per il committente.
\end{itemize}
Il progettista redige la specifica tecnica, la definizione di prodotto e le sezioni del piano di qualifica riguardanti le metriche delle attività di verifica della programmazione.
\paragraph{Programmatore}
Il programmatore è responsabile delle attività di codifica e delle commenti ausiliarie necessari per il processo di verifica.
In particolare i suoi compiti sono:
\begin{itemize}
	\item Implementare in modo rigoroso le soluzioni descritte dal progettista;
	\item Scrivere codice documentato e che rispetti le convenzioni e le metriche stabilite;
	\item Implementare i test da eseguire sul codice scritto necessari per l'attività di verifica.
\end{itemize}
Il programmatore  ha il compito di redigere il manuale utente. 
\paragraph{Verificatore}
Il verificatore è responsabile delle attività di verifica.
I suoi compiti sono:
\begin{itemize}
	\item Controllare la conformità del prodotto ad ogni stadio del sup ciclo di vita;
	\item garantire che le attività attuate seguano le norme stabilite.
\end{itemize}
Il \emph{verificatore} redige la sezione del piano di qualifica che illustra l'esito delle verifiche effettuate.


\subsubsection{Pianificazione}
\paragraph{Strumenti per la pianificazione}
La pianificazione di progetto è uno dei compiti del responsabile di progetto. Il gruppo ha valutato diversi strumenti per gestire la pianificazione. È stata subito scartata l'idea di usare un semplice foglio di calcolo, per i seguenti motivi:
\begin{itemize}
	\item l'attività di pianificazione deve poter essere modificata da ogni responsabile di progetto;
	\item è necessario tracciare le ore-persona assegnate ad ogni singolo task e come esse sono ripartite tra i vari membri del gruppo;
	\item è desiderabile avere una schermata automatica contenente tutte le ore di lavoro assegnate ad ogni persona durante tutta la durata del progetto;
	\item è desiderabile poter visualizzare come le stime differiscano dal lavoro effettivamente svolto.
\end{itemize}
Inizialmente è stata rivolta l'attenzione a \gloss{Trello}, accoppiato ad un servizio esterno chiamato EleGantt; tuttavia nel suo uso iniziale sono sorte diverse criticità:
\begin{itemize}
	\item principalmente, la \textbf{mancanza di struttura} che dovrebbe permettere a Trello un lavoro più agile si è rivelata inefficace in fase di pianificazione;
	\item lo strumento EleGantt, usato per stendere dei diagrammi di Gantt (non nativi in Trello) era troppo limitato nella sua versione gratuita.
\end{itemize}
Il gruppo ha quindi adottato i servizi offerti da Asana, accoppiato a InstaGantt (un servizio esterno molto ben integrato con Asana), principalmente per avvalersi delle seguenti funzionalità:
\begin{itemize}
	\item creazione di task (compiti);
	\item organizzazione dei task;
	\item disegno di diagrammi di pianificazione.
\end{itemize}

\paragraph{Task} Per ogni task (cioè compito) bisogna indicare:
\begin{description}
	\item[nome] ogni task e sottotask dovrà avere un nome univoco per poter essere meglio tracciato;
	\item[descrizione] è possibile allegare una descrizione, dei file e dei riferimenti che non necessitino di essere tracciati nel repository;
	\item[persona assegnata] ogni task può avere al massimo una persona assegnata, secondo il principio \gloss{DRI}; 
	\item[data di completamento prevista]
	\item[data di inizio prevista] (da InstaGantt)
	\item[sottotask] qualora il task non possa essere assegnato esclusivamente ad una persona ma richieda una collaborazione, si spezza il lavoro in frammenti più contenuti, chiamati sottotask. Questi sottotask possono avere a loro volta sottotask ulteriori. L'obiettivo di questa suddivisione è raggiungere una corretta WBS, il più possibile quantificabile;
	\item[dipendenze tra task] (da InstaGantt) ogni task può necessitare il completamento di un altro task per poterlo iniziare;
	\item[ore previste] (da InstaGantt)
	\item[ore effettive] (da InstaGantt)
	\item[tag] per tematizzare il task.
\end{description}
\paragraph{Organizzazione dei task} Si è adottato il modello \emph{Board}: esso permette di raggruppare i task in colonne, in modo da avere una visione immediata dello stato di ogni documento o codice che è necessario produrre.
Attualmente sono state create le seguenti colonne:
\begin{description}
	\item[\gloss{Milestone}] contiene le milestone decise dal gruppo e quelle obbligatorie, definite dal \TV;
	\item[Ambiente di sviluppo] contiene dei task assegnati per indagare i migliori strumenti di sviluppo che sono stati adottati dal gruppo;
	\item[Analisi dei Requisiti] documento richiesto;
	\item[Piano di Qualifica] documento richiesto;
	\item[Piano di Progetto] documento richiesto;
	\item[Studio di Fattibilità] documento richiesto;
	\item[Norme di Progetto] documento richiesto;
	\item[Riunioni] contiene informazioni su ogni riunione (data, problematiche emerse);
	\item[Glossario] documento richiesto;
	\item[Varie] task minori che non possono essere rendicontati, solitamente a durata minore di un'ora;
	\item[Completamento Revisioni] contiene le date nelle quali si hanno incontri con il \TV al fine di avanzare con le varie revisioni; 
	\item[Definizione di Prodotto] documento richiesto;
	\item[Specifica Tecnica] documento richiesto;
	\item[Codifica] attività di codifica da effettuare;
	\item[Manuale Utente] documento richiesto;
	\item[Test di sistema] attività di verifica da effettuare.
\end{description}
\paragraph{Diagrammi di pianificazione}
InstaGantt permette di visualizzare i vari task in un asse temporale, producendo così un \gloss{diagramma di Gantt}. 
Vanno rispettate le seguenti convenzioni:
\begin{itemize}
	\item Il nome di ogni task o sottotask deve essere univoco; per alcuni task ripetuti, come ad esempio l'incremento di un certo documento, si inserisce in coda la revisione che lo richiede (ad esempio "Incremento Piano di Qualifica [RP]" significa che il piano di qualifica è stato incrementato a causa della deadline della revisione di progettazione del \TV).
	\item Ogni task di livello più basso dev'essere contrassegnato da un tag che sancisce il ruolo che una persona adotta per quel task; i ruoli sono quelli in sezione \ref{sec:ruoli}, identici a quelli definiti in \PdP.
	\item Ogni task di livello superiore che produce un documento possiede il tag \texttt{Documento}; questo task è assegnato all'utente virtuale \texttt{Hivex Team}.
	\item I vari cicli di incremento vanno pianificati come task appartenenti allo stesso livello.
\end{itemize}
La sezione \emph{Workload} in InstaGantt permette di visualizzare i vari task assegnati ad ogni persona; grazie a questo si può analizzare il quantitativo di ore di lavoro impiegato giornalmente, con la possibilità di filtrarlo per ruolo, attraverso l'uso dei tag. Per questo, il responsabile di progetto è tenuto a:
\begin{itemize}
	\item riallocare task assegnati in caso di indisposizione di uno dei membri;
	\item controllare la presenza di task non assegnati.
\end{itemize}

\paragraph{Baseline} Infine è compito del responsabile di progetto salvare una \emph{\gloss{baseline}} del progetto ad ogni milestone raggiunta: in questo modo è possibile confrontare il lavoro pianificato con quello effettivamente svolto e stilare il consuntivo.

\paragraph{diagrammi di Gantt} Non si ritiene inoltre che i diagrammi PERT possano essere efficaci per una rappresentazione immediata dei rischi della pianificazione. Il responsabile di progetto deve, invece, fornire solamente i diagrammi di Gantt con le relative date effettive di completamento.


\subsubsection{Riunioni}
Spetta al responsabile di progetto convocare le riunioni quando lo ritiene necessario. È possibile da una qualsiasi persona del team fare richiesta di una riunione al responsabile di progetto. Quest'ultimo poi ha il compito di decidere se è utile svolgerla. Per informare i membri della riunione si utilizza la piattaforma di comunicazione Slack,proponendo una data, un luogo, l'ordine del giorno e chi ha chiesto la riunione. I membri del gruppo devono quindi rispondere tempestivamente per poter confermare la presenza.
\paragraph{Riunioni interne} Viene nominato un segretario ad inizio di ogni riunione che ha il compito di scrivere la minuta dell'incontro. A fine riunione deve inoltre redigere un verbale,il quale viene caricato nella repository insieme agli altri documenti per essere disponibile per la lettura ai membri. I partecipanti devono tenere un comportamento adeguato a favore la discussione dell'ordine del giorno.
\paragraph{Riunioni esterne} Il responsabile di progetto fissa le riunioni esterne contattando il committente tramite posta elettronica,accordandosi per la data e il luogo da poi riferire ai membri del gruppo.
Ad ogni riunione viene chiesto al committente di poter registrare la riunione in modo da poter redigere un verbale accurato e dare la possibilità di riascoltarla anche ad eventuali membri non presenti.Viene nominato anche qui un segretario che scriverà il verbale. Nel caso non fosse stato possibile registrare la riunione il verbale sarà redatto da tutto il team in modo da tralasciare il meno possibile contenuti.
\paragraph{Verbali} I verbali che vengono redatti dal segretario (o dal tutto il team in mancanza di registrazione audio) riassumono in modo sintetico ma preciso cosa o stato discusso nella riunione. In particolare specificano:
\begin{itemize}
	\item orario e giorno in cui si è svolta la riunione;
	\item durata della riunione;
	\item luogo dell'incontro;
	\item oggetto della riunione,ossia l'ordine del giorno;
	\item il segretario;
	\item i partecipanti alla riunione.
\end{itemize}
Sotto poi è presente un riassunto esaustivo riguardo le decisione prese rispetto agli argomenti trattati,eventuali dubbi e problemi ed eventuali compiti assegnati.


\subsubsection{Comunicazioni esterne}
Per le comunicazioni esterne il gruppo ha creato un indirizzo di posta elettronica (\email).
È compito del responsabile di progetto comunicare con il committente e il proponente e informare i restanti membri di cosa si è discusso.


\subsubsection{Comunicazione intra-gruppo} 
Una comunicazione tra i membri del gruppo è essenziale per la buona riuscita di ogni progetto. Il gruppo ritiene che un buon sistema di comunicazione debba possedere le seguenti caratteristiche:
\begin{itemize}
	\item invio e ricezione istantanea di messaggi;
	\item storico dei messaggi inviati;
	\item possibilità di avere notifiche push sia in ambiente desktop che smartphone;
	\item comunicazione tra tutti i membri del gruppo.
\end{itemize}
Tra i prodotti valutati, la scelta è ricaduta su Slack, una piattaforma di comunicazione pensata appositamente per gruppi di lavoro, in grado di soddisfare ampiamente le richieste sopra elencate. Tra le funzionalità offerte più interessanti notiamo:
\begin{itemize}
	\item suddivisione delle conversazioni del gruppo in canali;
	\item messaggi privati tra due utenti;
	\item chiamate tra i membri del gruppo; 
	\item condivisione file tramite drag and drop;
	\item esistenza di app per smartphone e desktop;
	\item integrazione con servizi esterni (ad esempio con GitHub).
\end{itemize}
\paragraph{Canali} La possibilità di suddividere le conversazioni in canali è molto potente ma potenzialmente anche dispersiva: avere troppi canali porta a riversare tutta la comunicazione sul canale principale, intasandolo e rendendo la lettura dello storico più complicata. Sono quindi previsti i seguenti canali, con i seguenti scopi:
\begin{description}
	\item[\#documents] come strutturare i documenti e problematiche relative all'uso di Latex;
	\item[\#feasibility] discussione sulla fattibilità dei capitolati;
	\item[\#general] annunci e comunicazioni riguardanti l'intero gruppo;
	\item[\#github] problematiche nell'uso di Git, integrazione con GitHub (vedi prossimo paragrafo);
	\item[\#meta] strutturazione canali di Slack;
	\item[\#project-planning] pianificazione del progetto;
	\item[\#random] discussioni non inerenti al progetto;
	\item[\#requirements] problematiche su requisiti e sull'utilizzo di PragmaDB.
\end{description}
Il numero di canali non dev'essere più di tre volte il numero di componenti del gruppo; la creazione di canali ulteriori è possibile solo previa archiviazione di canali non più utilizzati.
\paragraph{Integrazione con GitHub} Slack offre, nella sua versione gratuita, l'integrazione di un massimo di 10 servizi esterni. Un servizio che si è rivelato utile è stato l'integrazione con GitHub: questa crea un bot, inserito nel canale \#github, il quale invia notifiche relative a commit, pull request e attività nei GitHub Issues.




\appendix

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Definizione delle metriche
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Definizione delle metriche}



\subsection{Copertura dei requisiti obbligatori}
Questa metrica permette di verificare in ogni momento lo stato dei requisiti obbligatori coperti. Essa rappresenta il rapporto tra i requisiti obbligatori soddisfatti e il numero totale di requisiti obbligatori ricavati.

La misura viene effettuata nel modo seguente:
\begin{equation}
	\frac{~numero~requisiti~obbligatori~soddisfatti}{~numero~requisiti~obbligatori~totali}\times{100}
\end{equation}



\subsection{Copertura dei requisiti desiderabili}
Tale metrica permette di verificare in ogni momento lo stato dei requisiti desiderabili coperti. Essa rappresenta il rapporto tra i requisiti desiderabili soddisfatti e il numero totale di requisiti desiderabili ricavati.

La misura viene effettuata nel modo seguente:
\begin{equation}
	\frac{~numero~requisiti~desiderabili~soddisfatti}{~numero~requisiti~desiderabili~totali}\times{100}
\end{equation}



\subsection{Percentuale di test superati}
Tale metrica permette di verificare in ogni momento la percentuale di test superati.

La misura viene effettuata nel modo seguente:
\begin{equation}
	\frac{~numero~test~eseguiti}{~numero~test~pianificati}\times{100}
\end{equation}



\subsection{Profondità di annidamento dei blocchi}
Tale metrica misura il massimo numero di annidamento di blocchi di scoping all'interno di un particolare metodo. Metodi con un numero eccessivo di blocchi annidati possono risultare sono difficili da comprendere e portano potenzialmente all'errore.



\subsection{Numero di linee di codice per metodo}
La metrica misura il numero di linee di codice di un particolare metodo del programma. In particolare una linea di codice è considerata tale se contiene caratteri diversi da commenti e spaziature. Avere un numero di linee di codice per metodo relativamente basso permette di tenere un livello di manutenibilità accettabile. Un metodo eccessivamente articolato può risultare di contro difficile da comprendere e modificare e pertanto potrebbe essere necessario fattorizzarlo in più metodi con responsabilità meglio circoscritte e definite.



\subsection{Numero di parametri per metodo}
La metrica è la misura del numero totale di parametri formali in ingresso di un particolare metodo. Se il numero di parametri è elevato, lo \gloss{stack} del programma può essere riempito rapidamente in caso di multiple chiamate innestate e il metodo può risultare difficilmente comprensibile e mantenibile; inoltre ciò potrebbe indicare un metodo troppo complesso e non efficacemente suddiviso in sotto-metodi. In generale, inoltre, codice sorgente con invocazioni di metodi con una lunga lista di parametri è maggiormente soggetto all'errore.



\subsection{Numero di campi dati per classe}
Tale metrica indica il numero di campi dati dichiarati all'interno di una particolare classe o interfaccia. Maggiore è il numero di campi dati che una classe o un interfaccia contiene, maggiore è il numero di problemi che possono verificarsi quando essa viene estesa o implementata: un \emph{override} indesiderato di campi dati protetti o pubblici può provocare malfunzionamenti del programma. Un numero eccessivo di attributi all'interno di una classe, inoltre, può essere indice di mancanza di coesione nelle responsabilità ad essa assegnate.



\subsection{Numero di metodi per classe}
Tale metrica indica il numero di metodi definiti in una classe. Un valore molto alto potrebbe indicare una cattiva decomposizione delle funzionalità a livello di progettazione. Vengono esclusi dal conteggio i metodi \emph{\gloss{setter}} e \emph{\gloss{getter}}.



\subsection{Grado di accoppiamento afferente per package}
Tale metrica indica per un particolare package il numero di classi ed interfacce al suo esterno che dipendono da classi ed interfacce all'interno del package stesso.

In particolare, c'è una dipendenza tra una classe o interfaccia $C$ verso una classe o interfaccia $D$ se:
\begin{itemize}
	\item{$C$ ha un attributo di tipo $D$;}
	\item{$C$ ha un metodo con un parametro di tipo $D$;}
	\item{$C$ ha un'associazione, aggregazione o composizione verso $D$ (solo per i diagrammi UML);}
	\item{$C$ ha una dipendenza UML d'uso verso $D$ (solo per i diagrammi UML);}
	\item{$C$ è sottoclasse diretta di $D$;}
	\item{$C$ implementa l'interfaccia $D$.}
\end{itemize}
Un alto valore di accoppiamento efferente è caratteristico dei package di utilità i cui servizi sono ampiamente sfruttati e pertanto non è necessariamente indicativo di una cattiva progettazione. Tuttavia bisogna considerare che package con un alto grado di accoppiamento afferente devono avere un buon grado di stabilità, dal momento che futuri cambiamenti potrebbero avere un notevole impatto a livello dell'intera applicazione. Inoltre si può considerare che un alto numero di dipendenze entranti può essere considerato accettabile se il package è relativamente "astratto", meno se esso è invece più "concreto".



\subsection{Grado di accoppiamento efferente per package}
Tale metrica indica per un particolare package il numero di classi ed interfacce contenute al suo interno che dipendono da classi ed interfacce all'esterno del package stesso. Le dipendenze considerate sono quelle elencate nella sezione relativa al Grado di accoppiamento afferente di un package.

Un alto valore di accoppiamento efferente può indicare che il package non ha una responsabilità ben definita e circoscritta e può anche indicare che è potenzialmente instabile dal momento che esso dipende dalla stabilità di tutti i tipi a cui risulta accoppiato.

L'accoppiamento efferente può essere ridotto decomponendo le classi maggiormente accoppiate del package in sottoclassi.



\subsection{Complessità ciclomatica per metodo}
La metrica rappresenta la complessità di funzioni e metodi di un programma. Essa esprime il numero di cammini linearmente indipendenti presenti all'interno del codice del metodo o della funzione in esame. 

La misura viene effettuata nel modo seguente:
\begin{equation}
	Cyclomatic \ Number = e - n + 2p
\end{equation}
dove:
\begin{itemize}
	\item $e$ è il numero di archi;
	\item $n$ è il numero di nodi;
	\item $p$ è il numero di componenti connesse.
\end{itemize}
Alti valori di complessità ciclomatica sottintendono una ridotta manutenibilità del codice. Valori bassi di complessità ciclomatica potrebbero delineare una scarsa efficienza dei metodi.



\subsection{Numero di tipi per package}
La metrica misura il numero di tipi (classi ed interfacce) contenuti all'interno di un particolare package. Un valore elevato di tale metrica può essere indice di mancanza di coesione nelle responsabilità ad esso assegnate e pertanto di un basso livello di coesione funzionale, cosa che si ripercuote negativamente sulla comprensibilità, riusabilità e manutenibilità del package stesso. 



\subsection{Distanza dalla sequenza principale normalizzata} 
Tale metrica di package è basata sulla convinzione che il grado di astrattezza e stabilità di un package siano strettamente correlati ed è una misura derivata di astrattezza ($A$), ovvero la percentuale di classi astratte presenti nel package in esame, e instabilità ($I$). 

Package che sono massimamente stabili ($I = 0$) e allo stesso tempo massimamente astratti ($A = 1$) sono considerati buoni. Allo stesso modo, package che sono instabili ($I = 1$) e allo stesso tempo concreti ($A = 0$) sono considerati accettabili. Per essere considerato di buona qualità architetturale, un package dovrebbe idealmente collocarsi sul segmento di connessione di questi due punti su di un grafico $A \times I$. Questo segmento è detto sequenza principale.

La misura $D$ della distanza dalla sequenza principale viene effettuata nel modo seguente:
\begin{equation}
	D = | A + I - 1 | 
\end{equation}
I valori variano da 0 ad 1 dove 0 indica che il package sta direttamente sulla sequenza principale, mentre 1 indica che il package è massimamente distante da essa. Qualsiasi package piuttosto distante dal valore ideale 0 dovrebbe essere riesaminato e ristrutturato in modo tale da renderlo maggiormente riusabile e meno suscettibile ai cambiamenti.



\subsection{Instabilità}
Tale metrica misura il grado di instabilità di un particolare package.

Package che presentano molte dipendenze uscenti e poche dipendenze entranti sono poco stabili perché suscettibili ai cambiamenti degli elementi da cui dipendono; d'altro canto, package che presentano molte dipendenze entranti e poche dipendenze uscenti sono più stabili perché più difficili da modificare.

Il grado di instabilità $I$ di un package può essere misurato confrontando le dipendenze entranti ed uscenti nel modo seguente:	
\begin{equation}
	I = Ce/(Ca + Ce) 
\end{equation}
\begin{itemize}
	\item $Ce$ = grado di accoppiamento efferente;
	\item $Ca$ = grado di accoppiamento afferente;
\end{itemize}
I valori variano da 0 a 1 dove 0 indica un package massimamente stabile e 1 un package massimamente instabile.

Tuttavia bisogna considerare che non tutti i package devono essere completamente stabili o completamente instabili. Invece, ogni package dovrebbe essere intenzionalmente progettato per essere il più possibile stabile o instabile.
	


\subsection{Percentuale linee di commento su linee di codice}
Tale metrica misura il rapporto fra il numero di commenti inseriti all'interno del programma e il numero totale di linee di codice. Essa risulta utile per stimare la manutenibilità del codice dal momento che un'adeguata documentazione del codice ne permette una maggiore e più rapida comprensione.

Se la densità di commenti, per esempio, scende al di sotto di un certo valore soglia, questo può andare ad indicare che il codice non è adeguatamente commentato.

Un valore molto alto di tale metrica, tuttavia, può non essere considerato positivamente: una commento eccessivo del codice può risultare eccessivamente pedante, ridondante e frustrante nella sua lettura.



\subsection{Validazione W3C}
La metrica indica il numero di errori riscontrati dal validatore W3C nell'analisi delle pagine HTML5 del programma.

Una pagina valida assicura una notevole serie di vantaggi:
\begin{itemize}
 	\item c'è una maggiore possibilità che essa venga gestita in modo consistente dai diversi browser senza incappare in errori inattesi;
 	\item c'è una maggiore probabilità che la pagina, conforme agli standard web, sia correttamente gestita anche dalle future evoluzioni dei browser esistenti;
 	\item risulta più facilmente mantenibile nel breve e lungo periodo.
\end{itemize}



\subsection{Schedule Variance}
Tale metrica indica di quanto le macro-attività di progetto si discostano temporalmente rispetto alla pianificazione originaria definita nel documento \PdP . 

Viene calcolata come la differenza fra la data pianificata di fine di un'attività e la data reale di fine di quell'attività: un valore di \emph{schedule variance} minore di zero indica che l'attività di progetto considerata sta richiedendo più tempo di quanto pianificato; se pari a zero indica invece che essa è perfettamente in linea con le tempistiche previste mentre se è addirittura strettamente positivo indica che sta procedendo più speditamente di quanto considerato. 

Da sottolineare che l'utilizzo di periodi di slack aumenta la possibilità che la \emph{schedule variance} assuma valori positivi.



\subsection{Budget Variance}
Tale metrica indica quanto il costo di una particolare attività di progetto si discosta rispetto alla pianificazione originaria definita nel documento \PdP. 

Viene calcolata come la differenza fra il costo preventivato per un'attività e il costo effettivamente sostenuto per la stessa: un valore di \emph{budget variance} minore di zero indica che l'attività di progetto considerata sta richiedendo più risorse di quanto pianificato: se pari a zero indica invece che essa è perfettamente in linea con i costi previsti mentre se è addirittura strettamente positivo indica che sta procedendo con più efficienza di quanto considerato.



\subsection{Numero di violazioni di alta importanza delle norme di codifica}
La metrica misura il numero di violazioni di alta importanza delle norme di codifica segnalate dalla componente Audit del plug-in Eclipse CodePro Analytix. Un codice che non rispetta tali regole risulta difficilmente comprensibile e leggibile, poco coeso ed uniforme nella struttura e difficilmente mantenibile in futuro.



\subsection{Numero di violazioni di media importanza delle norme di codifica}
La metrica misura il numero di violazioni di media importanza delle norme di codifica segnalate dalla componente Audit del plug-in Eclipse CodePro Analytix. Un codice che non rispetta tali regole risulta difficilmente comprensibile e leggibile, poco coeso ed uniforme nella struttura e difficilmente mantenibile in futuro.



\subsection{Numero di violazioni di bassa importanza delle norme di codifica}
La metrica misura il numero di violazioni di bassa importanza delle norme di codifica segnalate dalla componente Audit del plug-in Eclipse CodePro Analytix. Un codice che non rispetta tali regole risulta difficilmente comprensibile e leggibile, poco coeso ed uniforme nella struttura e difficilmente mantenibile in futuro.



\subsection{Indice di Gulpease}
Tale metrica, tarata sulla lingua italiana, misura la qualità di un documento andando a stimarne il grado di leggibilità. Rispetto ad altri indici equivalenti per campo di applicazione ha il vantaggio di esprimere la lunghezza media delle parole in lettere anziché in sillabe --- cosa che ne consente una implementazione automatizzata fortemente affidabile. Tale indice, inoltre, considera principalmente due variabili linguistiche: la lunghezza delle parole e la lunghezza delle frasi in rapporto al numero delle lettere.

La formula per il calcolo dell'indice di Gulpease è la seguente:
\begin{equation}
	89+\frac{300\times(numero~delle~frasi)-10\times(numero~delle~lettere)}{numero~delle~parole}
\end{equation}
Il risultato è un valore compreso nell'intervallo [0,100], dove il valore 100 indica la più alta leggibilità, mentre 0 la più bassa. In generale risulta che testi con indice:
\begin{itemize}
	\item inferiore a 80 sono difficili da leggere per chi ha la licenza elementare;
	\item inferiore a 60 sono difficili da leggere per chi ha la licenza media;
	\item inferiore a 40 sono difficili da leggere per chi ha un diploma superiore.	
\end{itemize}
Si potrebbe osservare che i valori indicati nei range ottimali e di accettazione siano relativamente bassi; tuttavia non bisogna dimenticare che la documentazione prodotta relativamente al progetto corrente è inevitabilmente ricca di terminologie tecniche ed è rivolta a lettori con un significativo grado di istruzione e una certa familiarità con gli ambiti affrontati.



\subsection{Numero di violazioni della completezza architetturale di alta importanza}
La metrica misura il numero di violazioni della completezza architetturale di alta importanza segnalate dal programma SDMetrics. Una violazione di tali regole costituisce una pratica di progettazione non legale o comunque fortemente sconsigliata e con un forte impatto negativo sulla qualità del sistema. Il problema dovrebbe essere risolto in ogni circostanza.



\subsection{Numero di violazioni della completezza architetturale di media importanza}
La metrica misura il numero di violazioni della completezza architetturale di media importanza segnalate dal programma SDMetrics. Una violazione di tali regole può impattare negativamente sulla qualità del sistema. Il problema dovrebbe essere risolto se non vi è alcuna giustificazione per la violazione.



\subsection{Numero di violazioni della completezza architetturale di bassa importanza}
La metrica misura il numero di violazioni della completezza architetturale di bassa importanza segnalate dal programma SDMetrics. Una violazione di tali regole non ha un particolare impatto negativo sulle qualità del sistema, ma risolverla porta sicuramente ad una maggiore qualità dell'architettura generale.

\subsection{Numero di violazioni dello stile architetturale di alta importanza}
La metrica misura il numero di violazioni dello stile architetturale di alta importanza segnalate dal programma SDMetrics. Una violazione di tali regole costituisce una pratica di progettazione non legale o comunque fortemente sconsigliata e con un forte impatto negativo sulla qualità del sistema. Il problema dovrebbe essere risolto in ogni circostanza.

\subsection{Numero di violazioni dello stile architetturale di media importanza}
La metrica misura il numero di violazioni dello stile architetturale di media importanza segnalate dal programma SDMetrics. Una violazione di tali regole può impattare negativamente sulla qualità del sistema. Il problema dovrebbe essere risolto se non vi è alcuna giustificazione per la violazione.

\subsection{Numero di violazioni dello stile architetturale di bassa importanza}
La metrica misura il numero di violazioni dello stile architetturale di bassa importanza segnalate dal programma SDMetrics. Una violazione di tali regole non ha un particolare impatto negativo sulle qualità del sistema, ma risolverla porta sicuramente ad una maggiore qualità dell'architettura generale.

\subsection{Numero di violazioni della correttezza architetturale di alta importanza}
La metrica misura il numero di violazioni della correttezza architetturale di alta importanza segnalate dal programma SDMetrics. Una violazione di tali regole costituisce una pratica di progettazione non legale o comunque fortemente sconsigliata e con un forte impatto negativo sulla qualità del sistema. Il problema dovrebbe essere risolto in ogni circostanza.

\subsection{Numero di violazioni della correttezza architetturale di media importanza}
La metrica misura il numero di violazioni della correttezza architetturale di media importanza segnalate dal programma SDMetrics. Una violazione di tali regole può impattare negativamente sulla qualità del sistema. Il problema dovrebbe essere risolto se non vi è alcuna giustificazione per la violazione.

\subsection{Numero di violazioni della correttezza architetturale di bassa importanza}
La metrica misura il numero di violazioni della correttezza architetturale di bassa importanza segnalate dal programma SDMetrics. Una violazione di tali regole non ha un particolare impatto negativo sulle qualità del sistema, ma risolverla porta sicuramente ad una maggiore qualità dell'architettura generale.

\subsection{Statement Coverage}
La metrica indica la percentuale di istruzioni che sono eseguite durante i test. Un'alta percentuale di istruzioni coperte dai test eseguiti comporta una maggiore probabilità che le componenti testate abbiano un ridotto numero di errori. Si può aumentare tale indice evitando di considerare i metodi che non richiedono test, come i metodi getter e setter.

\subsection{Branch Coverage}
Tale metrica indica in percentuale il numero di cammini decisionali percorsi in ambito di testing rispetto al totale presente all'interno del codice. A differenza dello \gloss{Statement} Coverage che si limita a verificare la copertura di istruzioni, nel momento in cui tutti i rami decisionali sono coperti tale metrica assicura che nessuno di essi porti ad errori o situazioni inconsistenti.

\subsection{Percentuale di test di unità eseguiti}
Tale metrica indica la percentuale di test di unità eseguiti.

La misura viene effettuata nel modo seguente:
\begin{equation}
	\frac{numero~test~unità~eseguiti}{numero~test~unità~pianificati}\times100
\end{equation}

\subsection{Percentuale di test di integrazione eseguiti}
Tale metrica indica la percentuale di test di integrazione eseguiti.

La misura viene effettuata nel modo seguente:
\begin{equation}
	\frac{numero~test~integrazione~eseguiti}{numero~test~integrazione~pianificati}\times100
\end{equation}



\subsection{Percentuale di test di sistema eseguiti}
Tale metrica indica la percentuale di test di sistema eseguiti.

La misura viene effettuata nel modo seguente:
\begin{equation}
	\frac{numero~test~sistema~eseguiti}{numero~test~sistema~pianificati}\times100
\end{equation}

\subsection{Percentuale di test di validazione eseguiti}
Tale metrica indica la percentuale di test di validazione eseguiti.

La misura viene effettuata nel modo seguente:
\begin{equation}
	\frac{numero~test~validazione~eseguiti}{numero~test~validazione~pianificati}\times100
\end{equation}

\subsection{Numero di figli diretti}
Questa metrica misura il numero di sottoclassi dirette di una particolare superclasse. Il valore di tale metrica indica approssimativamente il grado di riuso di una componente elementare dell'applicazione. C'è inoltre da considerarsi che maggiore è il numero di figli diretti di una classe, maggiore è la responsabilità di chi ha il compito di manutenere tale classe per non impattare sul comportamento dei figli. Pertanto è più difficile modificare la classe ed essa richiede maggiore attenzione in fatto di testing.

\subsection{Profondità nella gerarchia}
Questa metrica misura il livello di profondità di una classe all'interno della gerarchia a cui essa appartiene. 

La profondità di un'interfaccia è stabilita pari a (1). La profondità della classe \texttt{java.lang.Object} è stabilita pari a (1). La profondità di ogni altra classe è definita come 1 + profondità della sua superclasse diretta

Più una classe è posizionata in profondità all'interno di una gerarchia, maggiore è il numero di metodi e campi dati che essa potenzialmente eredita, cosa che rende più difficile controllare e predire il suo comportamento. Essa diventa più specializzata e può essere difficile comprendere un sistema con più livelli di profondità. Tuttavia, bisogna anche considerare che c'è un grande potenziale nel riuso dei metodi ereditati.

Pertanto se un valore troppo alto di tale metrica è indice di un grado di complessità dell'architettura da limitarsi, un valore eccessivamente basso sottolinea un potenziale sottouso dei vantaggi dell'architettura orientata agli oggetti.

\end{document}
